<#@ template debug="true" hostSpecific="true" #>
<#@ import namespace="System.Diagnostics" #>
<#@ assembly name="Microsoft.EntityFrameworkCore" #>
<#@ assembly name="Microsoft.EntityFrameworkCore.Design" #>
<#@ assembly name="Microsoft.EntityFrameworkCore.Relational" #>
<#@ assembly name="Microsoft.Extensions.DependencyInjection.Abstractions" #>
<#@ parameter name="EntityType" type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" #>
<#@ parameter name="Options" type="Microsoft.EntityFrameworkCore.Scaffolding.ModelCodeGenerationOptions" #>
<#@ parameter name="NamespaceHint" type="System.String" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.ComponentModel.DataAnnotations" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="Microsoft.EntityFrameworkCore" #>
<#@ import namespace="Microsoft.EntityFrameworkCore.Design" #>
<#@ import namespace="Microsoft.Extensions.DependencyInjection" #>
<#@ import namespace="Microsoft.EntityFrameworkCore.Metadata" #>
<#@ import namespace="Microsoft.EntityFrameworkCore.Scaffolding" #>
<#
    // Template version: 703 - please do NOT remove this line
    if (EntityType.IsSimpleManyToManyJoinEntityType())
    {
        // Don't scaffold these
        return "";
    }
    if ((EntityType.Name).Contains("udw"))
    {
        // Don't scaffold these
        return "";
    }
    if ((EntityType.Name).Contains("@"))
    {
        // Don't scaffold these
        return "";
    }

    var services = (IServiceProvider)Host;
    var annotationCodeGenerator = services.GetRequiredService<IAnnotationCodeGenerator>();
    var code = services.GetRequiredService<ICSharpHelper>();

    var usings = new List<string>
    {
        "System",
        "System.Collections.Generic",
        "Microsoft.EntityFrameworkCore.ChangeTracking",
        "gip.core.datamodel",
        "Microsoft.EntityFrameworkCore.Infrastructure"
    };

    if (Options.UseDataAnnotations)
    {
        usings.Add("System.ComponentModel.DataAnnotations");
        usings.Add("System.ComponentModel.DataAnnotations.Schema");
        usings.Add("Microsoft.EntityFrameworkCore");
    }

    if (!string.IsNullOrEmpty(NamespaceHint))
    {
#>
namespace <#= NamespaceHint #>;

<#
    }

    if (!string.IsNullOrEmpty(EntityType.GetComment()))
    {
#>
/// <summary>
/// <#= code.XmlComment(EntityType.GetComment()) #>
/// </summary>
<#
    }

    if (Options.UseDataAnnotations)
    {
        foreach (var dataAnnotation in EntityType.GetDataAnnotations(annotationCodeGenerator))
        {
#>
<#= code.Fragment(dataAnnotation) #>
<#
        }
    }
    bool setInsertUpdateInterface = false;
    bool setISequenceInterface = false;
    bool setTargetQuantityInterface = false;
    bool setScheduledOrderInterface = false;
    bool setDeleteInfoInterface = false;
    List<String> propertyNames = new List<String>();
    foreach (var property in EntityType.GetProperties().OrderBy(p => p.GetColumnOrder() ?? -1))
    {
        propertyNames.Add(property.Name);
    }
    if (propertyNames.Contains("UpdateName") && propertyNames.Contains("UpdateDate") && propertyNames.Contains("InsertName") && propertyNames.Contains("InsertDate"))
    {
        setInsertUpdateInterface = true;
    }
    if (propertyNames.Contains("Sequence"))
    {
        setISequenceInterface = true;
    }
    if (propertyNames.Contains("TargetQuantity"))
    {
        setTargetQuantityInterface = true;
    }
    if (propertyNames.Contains("ScheduledOrder"))
    {
        setScheduledOrderInterface = true;
    }
    if (propertyNames.Contains("DeleteDate"))
    {
        setDeleteInfoInterface = true;
    }

    bool setMDTransInterface = false;
    if (propertyNames.Contains("MDNameTrans") && propertyNames.Contains("MDKey"))
    {
        setMDTransInterface = true;
    }
#>
public partial class <#= EntityType.Name #> : VBEntityObject<#= setInsertUpdateInterface ? ", IInsertInfo, IUpdateInfo" : "" #><#= setDeleteInfoInterface ? ", IDeleteInfo" : "" #><#= setMDTransInterface ? ", IMDTrans" : "" #><#= setISequenceInterface ? ", ISequence" : "" #><#= setTargetQuantityInterface ? ", ITargetQuantity" : "" #><#= setScheduledOrderInterface ? ", IScheduledOrder" : "" #>
{

    public <#= EntityType.Name #>()
    {
    }

    private <#= EntityType.Name #>(ILazyLoader lazyLoader)
    {
        LazyLoader = lazyLoader;
    }

    private ILazyLoader LazyLoader { get; set; }
    
<#
    var firstProperty = true;
    foreach (var property in EntityType.GetProperties().OrderBy(p => p.GetColumnOrder() ?? -1))
    {
        if (!firstProperty)
        {
            WriteLine("");
        }

        if (!string.IsNullOrEmpty(property.GetComment()))
        {
#>
    /// <summary>
    /// <#= code.XmlComment(property.GetComment(), indent: 1) #>
    /// </summary>
<#
        }

        if (Options.UseDataAnnotations)
        {
            var dataAnnotations = property.GetDataAnnotations(annotationCodeGenerator)
                .Where(a => !(a.Type == typeof(RequiredAttribute) && Options.UseNullableReferenceTypes && !property.ClrType.IsValueType));
            foreach (var dataAnnotation in dataAnnotations)
            {
#>
    <#= code.Fragment(dataAnnotation) #>
<#
            }
        }

        usings.AddRange(code.GetRequiredUsings(property.ClrType));

        var needsNullable = Options.UseNullableReferenceTypes && property.IsNullable && !property.ClrType.IsValueType;
        var needsInitializer = Options.UseNullableReferenceTypes && !property.IsNullable && !property.ClrType.IsValueType;
        bool needsOverride = property.Name == ("ACIdentifier") || property.Name == ("XMLConfig");
        bool needsNew = property.Name == ("EntityKey");
        bool changeTrackingProxiesUsed = false;

        string navigationName;
        string navigationKeyPath;
        bool hasNavigation = GetNavigationInfoForProperty(Options, EntityType, property, out navigationName, out navigationKeyPath);
        if (hasNavigation)
        {
#>
    <#=code.Reference(property.ClrType)#><#= needsNullable ? "?" : "" #> _<#= property.Name #>;
    public <#= needsOverride ? "override " : changeTrackingProxiesUsed ? "virtual " : "" #><#= needsNew ? "new " : "" #><#= code.Reference(property.ClrType) #><#= needsNullable ? "?" : "" #> <#= property.Name #> 
    {
        get { return _<#= property.Name#>; }
        set { SetForeignKeyProperty<<#=code.Reference(property.ClrType)#><#= needsNullable ? "?" : "" #>>(ref _<#= property.Name#>, value, "<#= navigationName#>", _<#= navigationName#>, <#= navigationName#> != null ? <#= navigationKeyPath#> : default(<#= code.Reference(property.ClrType)#>)); }
    }<#= needsInitializer ? " = null!;" : "" #>
<#
        }
        else
        {
#>
    <#=code.Reference(property.ClrType)#><#= needsNullable ? "?" : "" #> _<#= property.Name #>;
    public <#= needsOverride ? "override " : changeTrackingProxiesUsed ? "virtual " : "" #><#= needsNew ? "new " : "" #><#= code.Reference(property.ClrType) #><#= needsNullable ? "?" : "" #> <#= property.Name #> 
    {
        get { return _<#= property.Name#>; }
        set { SetProperty<<#=code.Reference(property.ClrType)#><#= needsNullable ? "?" : "" #>>(ref _<#= property.Name#>, value); }
    }<#= needsInitializer ? " = null!;" : "" #>
<#
        }
        firstProperty = false;
    }

    foreach (var navigation in EntityType.GetNavigations())
    {
        WriteLine("");

        if (Options.UseDataAnnotations)
        {
            foreach (var dataAnnotation in navigation.GetDataAnnotations(annotationCodeGenerator))
            {
#>
    <#= code.Fragment(dataAnnotation) #>
<#
            }
        }

        string targetType = navigation.TargetEntityType.Name;
        string navName = navigation.Name;
        string relName = "";
        if (navigation.IsCollection && !(navName.Contains("@")))
        {
            if (navName.Contains("Inverse"))
            {
                string navNameRef = navName.Remove(0,7);
                relName = targetType + "_" + navNameRef;
            }
            else
            {
                string pkName = navigation.ForeignKey.PrincipalToDependent.ToString();
                string pkIdName = pkName.Split("Inverse: ").Last();
                relName = targetType + "_" + pkIdName;
            }
#>
    private ICollection<<#= targetType #>> _<#= relName #>;
    public virtual ICollection<<#= targetType #>> <#= relName #>
    {
        get { return LazyLoader.Load(this, ref _<#= relName #>); }
        set { SetProperty<ICollection<<#= targetType #>>>(ref _<#= relName #>, value); }
    }

    public bool <#= relName #>_IsLoaded
    {
        get
        {
            return _<#= relName #> != null;
        }
    }

    public virtual CollectionEntry <#= relName + "Reference"#>
    {
        get { return Context.Entry(this).Collection(c => c.<#= relName #>); }
    }
<#
        }
        else if(!(navigation.Name.Contains("@")))
        {
            bool needsNullable;
            bool needsInitializer;
            string navigationName;
            GetDeclarationInfoForNavigation(Options, EntityType, navigation, targetType, out needsNullable, out needsInitializer, out navigationName);
        #>
    private <#= targetType #><#= needsNullable ? "?" : "" #> _<#= navigationName #>;
    public virtual <#= targetType #><#= needsNullable ? "?" : "" #> <#= navigationName #>
    { 
        get { return LazyLoader.Load(this, ref _<#= navigationName #>); } 
        set { SetProperty<<#= targetType#><#= needsNullable ? "?" : "" #>>(ref _<#= navigationName#>, value); }
    }<#= needsInitializer ? " = null!;" : "" #>

    public bool <#= navigationName #>_IsLoaded
    {
        get
        {
            return _<#= navigationName #> != null;
        }
    }

    public virtual ReferenceEntry<#= needsNullable ? "?" : "" #> <#= navigationName+"Reference" #> 
    {
        get { return Context.Entry(this).Reference("<#=navigationName#>"); }
    }<#= needsInitializer ? " = null!;" : "" #>
    <#
        }
    }

    foreach (var skipNavigation in EntityType.GetSkipNavigations())
    {
        WriteLine("");

        if (Options.UseDataAnnotations)
        {
            foreach (var dataAnnotation in skipNavigation.GetDataAnnotations(annotationCodeGenerator))
            {
#>
    <#= code.Fragment(dataAnnotation) #>
<#
            }
        }
#>
    private ICollection<<#= skipNavigation.TargetEntityType.Name #>> _<#= skipNavigation.Name #>;
    public virtual ICollection<<#= skipNavigation.TargetEntityType.Name #>> <#= skipNavigation.Name #>
    {
        get { return LazyLoader.Load(this, ref _<#= skipNavigation.Name #>); }
        set { SetProperty<ICollection<<#= skipNavigation.TargetEntityType.Name #>>>(ref _<#= skipNavigation.Name #>, value); }
    }

    public virtual CollectionEntry <#= skipNavigation.Name + "Reference"#>
    {
        get { return Context.Entry(this).Collections(c => c.<#= skipNavigation.Name #>); }
    }
<#
    }
#>
}
<#
    var previousOutput = GenerationEnvironment;
    GenerationEnvironment = new StringBuilder();

    foreach (var ns in usings.Distinct().OrderBy(x => x, new NamespaceComparer()))
    {
#>
using <#= ns #>;
<#
    }

    WriteLine("");

    GenerationEnvironment.Append(previousOutput);
#>
<#+
    public void GetDeclarationInfoForNavigation(ModelCodeGenerationOptions options, IEntityType entityType, INavigation navigation, string targetType, out bool needsNullable, out bool needsInitializer, out string navigationName)
    {
        if (string.IsNullOrEmpty(targetType))
        {
            targetType = navigation.TargetEntityType.Name;
            if (targetType.Contains("@"))
                targetType = targetType.Remove(0, 1);
        }
        string navName = navigation.Name;

        needsNullable = options.UseNullableReferenceTypes && !(navigation.ForeignKey.IsRequired && navigation.IsOnDependent);
        needsInitializer = options.UseNullableReferenceTypes && navigation.ForeignKey.IsRequired && navigation.IsOnDependent;
        navigationName = navigation.Name;

        if (( !(navigation.ForeignKey.IsRequired && navigation.IsOnDependent) && targetType == entityType.Name) 
            || (navigation.Name == "BasedOn" + targetType)
            || navigation.Name.Contains("InverseBasedOn"))
        {
            if ((navigation.ForeignKey.DependentToPrincipal.Name == navigation.Name) && entityType.Name == navigation.TargetEntityType.Name)
            {
                navigationName = navigation.ForeignKey.PrincipalKey.DeclaringEntityType.Name + "1_" + navigation.Name;
            }
            else if (navigation.Name.Contains("InverseBasedOn"))
            {
                string[] navInvName = navigation.Name.Split("Inverse");
                if ((navigation.ForeignKey.DependentToPrincipal.Name == navInvName[1]) && entityType.Name == navigation.TargetEntityType.Name)
                {
                    navigationName = navigation.ForeignKey.PrincipalKey.DeclaringEntityType.Name + "1_" + navInvName[1];
                }
            }
        }
    }

    public bool GetNavigationInfoForProperty(ModelCodeGenerationOptions options, IEntityType entityType, IProperty property, out string navigationName, out string navigationKeyPath)
    {
        navigationName = null;
        navigationKeyPath = null;
        if (!property.IsForeignKey())
            return false;
        IForeignKey foreignKey = property.GetContainingForeignKeys().FirstOrDefault();
        if (foreignKey == null)
            return false;
        INavigation navigation = foreignKey.GetNavigation(true);
        if (navigation == null)
            navigation = foreignKey.GetNavigation(false);
        if (navigation == null)
            return false;
        bool needsNullable, needsInitializer;
        GetDeclarationInfoForNavigation(options, entityType, navigation, null, out needsNullable, out needsInitializer, out navigationName);
        if (navigation.ForeignKey == null || navigation.ForeignKey.PrincipalKey == null)
            return false;
        string fkID = navigation.ForeignKey.PrincipalKey.Properties.FirstOrDefault().Name;
        navigationKeyPath = $"{navigationName}.{fkID}";
        return true;
    }
#>